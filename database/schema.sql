-- Pluxo Database Schema (PostgreSQL / Supabase)

-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Users are managed by Supabase Auth (auth.users).
-- We can create a public profiles table if we want to store extra data, 
-- but for now we can just link VIP subscriptions to auth.users.id (uuid).

-- VIP Subscriptions Table
create table public.vip_subscriptions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  starts_at timestamp with time zone default timezone('utc'::text, now()) not null,
  ends_at timestamp with time zone not null,
  plan_type text default 'vip' check (plan_type in ('vip', 'vup')),
  active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Admin Messages Table
create table public.admin_messages (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete set null, -- Null for broadcast
  title text not null,
  message text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Predictions History Table
create table public.predictions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  result text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Payments Table (Managed by backend checkout)
-- create table public.payments (
--   id uuid default uuid_generate_v4() primary key,
--   user_id uuid references auth.users(id) on delete cascade,
--   external_id text,
--   amount decimal(12,2),
--   currency text,
--   status text,
--   plan_type text,
--   duration_minutes integer,
--   provider text,
--   onexbet_id text, -- ADDED: For tracking 1xbet verification
--   created_at timestamp with time zone default now()
-- );

-- RLS Policies (Row Level Security)

-- VIP Subscriptions: Users can read their own. Admins (service role) can do all.
alter table public.vip_subscriptions enable row level security;

create policy "Users can view own vip subscription"
  on public.vip_subscriptions for select
  using ( auth.uid() = user_id );

create policy "Admins can insert vip subscriptions"
  on public.vip_subscriptions for insert
  with check ( exists (select 1 from public.profiles where id = auth.uid() and role = 'admin') );

create policy "Admins can update vip subscriptions"
  on public.vip_subscriptions for update
  using ( exists (select 1 from public.profiles where id = auth.uid() and role = 'admin') );

-- Admin Messages: Users can read messages targeted to them or null (broadcast)
alter table public.admin_messages enable row level security;

create policy "Users can view own messages or broadcasts"
  on public.admin_messages for select
  using ( auth.uid() = user_id or user_id is null );

-- Predictions: Users can view their own predictions
alter table public.predictions enable row level security;

create policy "Users can view own predictions"
  on public.predictions for select
  using ( auth.uid() = user_id );

-- Note: Admin Role management is usually done via a separate 'profiles' table with a 'role' column,
-- or using Supabase Custom Claims. For simplicity in this demo, we can check for a specific email
-- or use a simple 'profiles' table.

create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  role text default 'user' check (role in ('user', 'admin')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles enable row level security;

create policy "Profiles are viewable by own user or admin"
  on public.profiles for select
  using ( auth.uid() = id or (exists (select 1 from public.profiles where id = auth.uid() and role = 'admin')) );

create policy "Users can insert their own profile"
  on public.profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile"
  on public.profiles for update
  using ( auth.uid() = id );

-- Trigger to create profile on signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'user');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
